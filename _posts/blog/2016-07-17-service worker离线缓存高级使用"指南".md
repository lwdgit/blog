service worker离线缓存是一种可编程的本地缓存方案。在这之前，我们要实现缓存可编程，无外乎是localStorage+方案（如basket)。关于这些方案的优缺点我们不做讨论，在这里我想讲的是下一代的"可编程缓存方案" ---- `service worker离线缓存`。

之前我对service worker离线缓存的一些基本概念及缓存策略进行了简单介绍，这次我会进一步深入，并详细讨论应用这种缓存方案可能出现的一些问题及其应对方案。

关于service worker缓存，网上能找到不少资料介绍它的用法及不少的demo。但是这些介绍都过于表面，而且场景也过于理想化。在实际应用场景中，我们不仅需要考虑“如何缓存”，更要考虑“如何使缓存失效”，也就是做到”`随心所欲的控制缓存`“。而这方面，介绍的文章并不多，所以接下来的”指南“，会结合自身使用service worker缓存的实际体会，指导大家如何跳过这一个个”坑“。

首先，我们先明确"service worker缓存"的这几个特性：

 1. 可缓存任何内容，包括html本身(视频也可以，单个文件最大64M)
 2. 理论上缓存是永远不会失效，除非手动清除缓存或者自行标志
 3. service worker进程会一直在后台运行，哪怕是浏览器已经退出。判断是否需要重新执行，是通过检测service worker文件自身是否有变化。所以要想让service worker更换执行指令，我们需要修改这个文件本身。（注意：这也就意味着这个文件本身不能有缓存，包括传统的浏览器cache，所以服务器端需要对这个文件设置`cache-control: no-cache` http头）
 4. 因为service worker可以在无网的环境下工作，所以便有了以下的缓存策略：networkFirst, cacheFirst, cacheOnly, networkOnly, fastest（网络与缓存竞争，一般情况下网络是不可能比缓存快，但是这种策略的好处是会实时更新缓存，所以这种方案可以很好地平衡速度与文件更新这两方面的矛盾）
 5. service worker缓存匹配全路径（hash除外)。如 `a.com/`与 `a.com/?from=xxx` 会被识别为不同路径。
 6. service worker可以缓存任何状态（如200, 404, 503等)，所以实际应用中我们应该过滤掉这些状态，比如只允许状态码为200的请求可以被缓存
 7. service worker是利用fetch方法向服务器端请求资源并缓存的，而fetch方法目前“不能跨域”，如果非要跨域，有两种办法：
    
    1. 增加`access-control-allow-origin:*`跨域头 
    2. Request对象里面将mode设置为'no-cors'，但是会损失返回状态（即无法判断文件是否请求成功）
 
--------
 我们来模拟一个真实环境：
  
  1. 网站应用高线缓存，用户A浏览器支持，并且离线缓存了这个网站的部分页面及资源
  2. 网站有更新，而此时用户A的浏览器不会向服务器发送任何请求(当然，我们明确指定不缓存的文件还是会向服务器端请求)
  3. 网站管理员更新service worker文件,并设置更新缓存的标志
  4. 用户A再次访问时检测到service worker文件变更。
  5. service worker文件更新后重新执行缓存步骤，检查是否需要更新缓存
  6. 浏览器更新缓存，用户看到新页面
  

 以上步骤中，我们需要确保的是----”至少有一个文件没有被缓存，这个文件一般是service worker本身“，我们姑且把这个文件叫”信使文件“。`信使文件`是用户与服务器联系的唯一通道，在断网情况下，`信使文件`发请求失败，但并不对用户浏览网页造成任何影响。
 
 我们再来模拟一个异常情况：
 
  1. 用户缓存了一个图处资源，但是这个图片资源刚好出现了404，于是缓存存了一张fallback图片
  2. 这个图片资源已经恢复正常，但是浏览器再也不去请求了

这种情况如果是可以预见的，并且只是上面举例了图片，那可能不是很糟糕，但是如果是js，css，并且是关键性的，那么对网站而言，直接意味着这个用户将一直无法访问该网站。所以在实际应用中，这点需要重点关注。

----------

当然，再怎么我们也不可能确保万无一失，所以在应用过程中，我们应该给用户一个通道，让用户可以自行关闭缓存。比如在用户一直不能加载某一个页面时，我们应应该给出一个提示：引导他如何手动请缓存，或者直接访问特定的url触发缓存清理操作。
  
应用的过程中，对异常的监控也是有必要的，但是比较“坑”的是，目前service worker大部分的错误无法被捕捉到。所以实际应用中，我们只能通过页面加载是否正常来判断是否是缓存出了问题。比如设定一个js异常预警值，当错误量超一个上限后，触发自动关闭缓存的开关。


--------------------

上面例举了一些在应用过程中会出现的问题，接下来我们总结一下，并分享一个自己在实际应用中的解决方案。


1. 对缓存状态进行过滤，只允许400以下的状态进入存储(实际使用中发现300-400之间的状态也不能存储，否则可能导致3xx跳转异常)。
2. 有时间戳，md5的资源可以完全放心使用，当你想让缓存失效时，改个时间戳，md5什么的，就自动失效了。这个和`穿透cdn`类似。
3. 对html页面的缓存需要尽可能小心。滥用将意味着面临`缓存失控`的风险。在任何情况下，都不应该使用cacheFirst, cacheOnly策略。对fastest策略也应当适当使用，如应用在对速度要求比较高的首页。其他情况下，最好还是使用networkFirst或networkOnly。当然，**`不缓存页面的离线缓存是没有意义的`**。
4. 设计一套”`缓存临时失效`“方案。如输入特定url可以让service worker自行清理缓存等。这不单单可以用来做为紧急方案，也可以用于方便开发。
5. 设计一个缓存共用方案，让不同url的页面可以共用一个缓存。（比如让 `a.com/?from=google`与`a.com/?from=baidu`可以共用一个缓存。）
6. 利用GCM消息推送机制，实现类app化的主动清缓存机制。因为现有的缓存清理机制都有至少一次的延时，也就是在服务器端更新了页面之后，用户要至少访问两次才能看到新页面。（当然，你也可以利用service worker主动向服务器发送查询请求，或建立websocket长连接来实现）
7. 初次使用时，缩短缓存有效时长，比如让缓存有效期只有6个小时，减少因配置不当导致用户长时间不能访问。


具体操作中，还有不少细节需要注意，我在这也没有办法全部例出来。如果你在使用service worker缓存的过程中，还遇到其他问题，欢迎前来提问。


